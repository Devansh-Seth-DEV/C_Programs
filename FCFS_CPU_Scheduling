/*
 * TODO:
 * 	Upgrade the logic
 * 	Remove the extra memory for READY QUEUE, add front and rear pointer to Process Array and teart it as a QUEUE
 * 	Sort the Process Array after insertion or apply insertion sort while inserting the processes at runtime
 *	After sorting treat the array as READY QUEUE
 */

#include <stdio.h>
#include <stdlib.h>

typedef struct prcs_t
{
	int pid;
	int arrival_tm;
	int burst_tm;
	int comp_tm;
	int turnAround_tm;
	int wait_tm;
} PRCS_T;


typedef struct prcs_queue_t
{
	PRCS_T** queue;
	size_t que_size;
	int front;
	int rear;
} PRCS_QUE;


int PRCS_INIT(PRCS_T* **tpPROC, size_t nmemb);
PRCS_T* PRCS_CREAT(int pid, int arrival_tm, int burst_tm);
void PRCS_SORT(PRCS_T* *dpPROC, size_t nmemb);
void PRCS_RUN(PRCS_QUE* pQUE);
double PRCS_AVG_TURNA_TM(PRCS_T* *dpPROC, size_t nmemb);
double PRCS_AVG_WAIT_TM(PRCS_T* *dpPROC, size_t nmemb);
void PRCS_RELEASE(PRCS_T* *dpPROC, size_t nmemb);


int PRCS_QUE_INIT(PRCS_QUE* *dpQUE, size_t nmemb);
int PRCS_QUE_ENQUEUE(PRCS_QUE* pQUE, PRCS_T* pPROC);
int PRCS_QUE_NMEM_ENQ(PRCS_QUE* pQUE, PRCS_T* *dpPROC, size_t nmemb);
PRCS_T* PRCS_QUE_DEQUEUE(PRCS_QUE* pQUE);
int PRCS_QUE_EMPTY(PRCS_QUE* pQUE);
void PRCS_QUE_RELEASE(PRCS_QUE* *dpQUE);


int main() {
	size_t nprcsMemb;
	int arrival_tm;
	int burst_tm;
	PRCS_T* *dpPRCS;
	PRCS_QUE* RDY_QUEUE;

	printf("FCFS Scheduling...\n");

	printf("Enter no. of process: ");
	scanf("%zu", &nprcsMemb);

	if (PRCS_INIT(&dpPRCS, nprcsMemb)) {
		perror("Can't initialize process batch\n");
		return 1;
	}
	
	if (PRCS_QUE_INIT(&RDY_QUEUE, nprcsMemb)) {
		perror("Can't initialize READY-QUEUE\n");
		return 2;
	}

	for (size_t i=0; i<nprcsMemb; i++) {
		printf("Process: %zu\n", i+1);
		printf("\tEnter arrival time: ");
		scanf("%d", &arrival_tm);
		printf("\tEnter burst time: ");
		scanf("%d", &burst_tm);
		

		PRCS_T* pPROC = PRCS_CREAT(i+1, arrival_tm, burst_tm);
		if (pPROC == NULL) {
			perror("Can't create process\n");
			return 3;
		}

		/*
		 * TODO:
		 * insert the process into the array using insertion sort technique, this'll insert the process as well as in a sorted manner
		 * instead of first inserting all the processes and then sorting the whole array
		 */

		dpPRCS[i] = pPROC;

		printf("\n");
	}

	/*
	 * TODO:
	 * don't make new QUEUE
	 * use the PROCESS ARRAY as a queue by adding a rear and front pointer to it
	 * Add and delete the element according to the QUEUE logic
	 */

	int exitStat = PRCS_QUE_NMEM_ENQ(RDY_QUEUE, dpPRCS, nprcsMemb);
	switch (exitStat) {
		case -1:
			perror("READY-QUEUE is not initialized\n");
			break;
		case -2:
			perror("READY-QUEUE is not created\n");
			break;
		case -3:
			perror("Hit NULL process in READY-QUEUE\n");
			break;
		case 0:
			break;
		default:
			printf("READY-QUEUE OVERFLOW\n");

	}

	printf("Running Processes...\n\n");

	PRCS_RUN(RDY_QUEUE);

	printf("\n");

	printf("Avg Turn Around Time: %.2lf\n", PRCS_AVG_TURNA_TM(dpPRCS, nprcsMemb));

	printf("Avg Waiting Time: %.2lf\n\n", PRCS_AVG_WAIT_TM(dpPRCS, nprcsMemb));

	PRCS_QUE_RELEASE(&RDY_QUEUE);
	PRCS_RELEASE(dpPRCS, nprcsMemb);
	
	return 0;
}


int PRCS_INIT(PRCS_T* **tpPROC, size_t nmemb) {
	*tpPROC = (PRCS_T**) calloc(nmemb, sizeof(PRCS_T*));
	if (tpPROC == NULL) {
		return 1;
	}

	return 0;
}


PRCS_T* PRCS_CREAT(int pid, int arrival_tm, int burst_tm) {
	PRCS_T* PPRCS =  (PRCS_T*) malloc(sizeof(PRCS_T));
	PPRCS->pid = pid;
	PPRCS->arrival_tm = arrival_tm;
	PPRCS->burst_tm = burst_tm;

	return PPRCS;
}


void PRCS_RELEASE(PRCS_T* *dpPROC, size_t nmemb) {
	if(dpPROC == NULL || nmemb <=0) {
		return;
	}

	for (size_t i=0; i<nmemb; i++) {
		if (dpPROC[i] == NULL) {
			continue;
		}

		free(dpPROC[i]);
		dpPROC[i] = NULL;
	}

	free(dpPROC);
	dpPROC = NULL;
}


void PRCS_SORT(PRCS_T* *dpPROC, size_t nmemb) {
	PRCS_T* key;
	ssize_t j;

	for (size_t i=1; i<nmemb; i++) {
		key = dpPROC[i];
		j = i-1;
		
		while (j>=0 && dpPROC[j]->arrival_tm > key->arrival_tm) {
			dpPROC[j+1] = dpPROC[j];
			j--;
		}

		dpPROC[j+1] = key; 
	}
}


void PRCS_RUN(PRCS_QUE* pQUE) {
	int comp_tm = 0;

	while (!PRCS_QUE_EMPTY(pQUE)) {
		PRCS_T* pPROC = PRCS_QUE_DEQUEUE(pQUE);

		if (comp_tm == 0) {
			comp_tm = pPROC->burst_tm + pPROC->arrival_tm;	
		} else {
			// check if CPU is in IDLE stage
			if (pPROC->arrival_tm > comp_tm) {
				// if CPU gets IDLE then compute new process completion time with increment of IDLE time taken by CPU
				comp_tm += pPROC->arrival_tm - comp_tm;
			}

			comp_tm += pPROC->burst_tm;
		}

		pPROC->comp_tm = comp_tm;
		pPROC->turnAround_tm = pPROC->comp_tm - pPROC->arrival_tm;
		pPROC->wait_tm = pPROC->turnAround_tm - pPROC->burst_tm;

		printf(
				"P.No: %d | A.T: %d | B.T: %d | C.T: %d | T.A.T: %d | W.T: %d\n",
				pPROC->pid,
				pPROC->arrival_tm,
				pPROC->burst_tm,
				pPROC->comp_tm,
				pPROC->turnAround_tm,
				pPROC->wait_tm
			 );
	}
}


double PRCS_AVG_TURNA_TM(PRCS_T* *dpPROC, size_t nmemb) {
	if (dpPROC == NULL || nmemb <= 0) {
		return 0;
	}

	double turnAround_tm = 0;

	for (size_t i=0; i<nmemb; i++) {
		turnAround_tm += dpPROC[i]->turnAround_tm;
	}

	return (turnAround_tm/(double) nmemb);
}


double PRCS_AVG_WAIT_TM(PRCS_T* *dpPROC, size_t nmemb) {
	if (dpPROC == NULL || nmemb <= 0) {
		return 0;
	}

	double wait_tm = 0;

	for (size_t i=0; i<nmemb; i++) {
		wait_tm += dpPROC[i]->wait_tm;
	}

	return (wait_tm/(double) nmemb);
}


int PRCS_QUE_INIT(PRCS_QUE* *dpQUE, size_t nmemb) {
	(*dpQUE) = (PRCS_QUE*) malloc(sizeof(PRCS_QUE));
	if (*dpQUE == NULL) {
		return -1;
	}

	(*dpQUE)->queue = (PRCS_T**) calloc(nmemb, sizeof(PRCS_T*));
	if ((*dpQUE)->queue == NULL) {
		return -2;
	}

	(*dpQUE)->que_size = nmemb;
	(*dpQUE)->front = -1;
	(*dpQUE)->rear = -1;

	return 0;
}


int PRCS_QUE_ENQUEUE(PRCS_QUE* pQUE, PRCS_T* pPROC) {
	if (pQUE == NULL) {
		return -1;
	}

	if (pQUE->queue == NULL) {
		return -2;
	}

	if (pQUE->front == -1 && pQUE->rear == -1) {
		pQUE->front++;
	}

	pQUE->rear++;
	if (pQUE->rear >= pQUE->que_size) {
		return pQUE->rear;
	}

	pQUE->queue[pQUE->rear] = pPROC;

	return 0;
}


int PRCS_QUE_NMEM_ENQ(PRCS_QUE* pQUE, PRCS_T* *dpPROC, size_t nmemb) {
	if (pQUE == NULL) {
		return -1;
	} else if (pQUE->queue == NULL) {
		return -2;
	} else if (*dpPROC == NULL || nmemb <= 0) {
		return -3;
	}

	PRCS_SORT(dpPROC, nmemb);

	for (size_t i=0; i<nmemb; i++) {
		int exitStat = PRCS_QUE_ENQUEUE(pQUE, dpPROC[i]);
		if (exitStat != 0) {
			perror("Can't enqueue process\n");
			return exitStat;
		}
	}

	return 0;
}


PRCS_T* PRCS_QUE_DEQUEUE(PRCS_QUE* pQUE) {
	if (pQUE == NULL || pQUE->queue == NULL) {
		return NULL;
	}

	if (pQUE->front == pQUE->rear) {
		PRCS_T* pPROC = pQUE->queue[pQUE->front];
		pQUE->queue[pQUE->front] = NULL;
		pQUE->front = -1;
		pQUE->rear = -1;

		return pPROC;
	} else if (pQUE->front > pQUE->rear) {
		pQUE->front = -1;
		pQUE->rear = -1;

		return NULL;
	}
	
	PRCS_T* pPROC = pQUE->queue[pQUE->front];
	pQUE->queue[pQUE->front++] = NULL;

	return pPROC;
}


int PRCS_QUE_EMPTY(PRCS_QUE* pQUE) {
	if (pQUE == NULL) {
		return -1;
	} else if (pQUE->queue == NULL) {
		return -2;
	}

	if (pQUE->front == -1 && pQUE->rear == -1) {
		return 1;
	}
	
	return 0;
}


void  PRCS_QUE_RELEASE(PRCS_QUE* *dpQUE) {
	if ((*dpQUE)->queue) {
		free((*dpQUE)->queue);
		(*dpQUE)->queue = NULL;
	}

	if (*dpQUE) {
		free(*dpQUE);
		*dpQUE = NULL;
	}
}
